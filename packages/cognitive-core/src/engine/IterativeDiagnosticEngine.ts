// packages/cognitive-core/src/engine/IterativeDiagnosticEngine.ts
// Motor de Diagn√≥stico Iterativo - Creado por Bernard Orozco
import { ClaudeAdapter } from '../decision-engine/providers/claude'
import { SOAPAnalysis, DiagnosticCycle, MedicalCase, AdditionalInfoRequest } from '../types/medical'
import { MedicalQualityValidator } from '../utils/medicalValidator'
import { CognitiveOrchestrator } from '../services/cognitiveOrchestrator'

interface DiagnosticEngineConfig {
  maxCycles: number
  confidenceThreshold: number
  qualityThreshold: number
}

export class IterativeDiagnosticEngine {
  private cycles: DiagnosticCycle[] = []
  private claudeAdapter: ClaudeAdapter
  private validator: MedicalQualityValidator
  private cognitiveOrchestrator: CognitiveOrchestrator
  private config: DiagnosticEngineConfig

  constructor(claudeAdapter?: ClaudeAdapter, config?: Partial<DiagnosticEngineConfig>) {
    this.claudeAdapter = claudeAdapter || new ClaudeAdapter()
    this.validator = new MedicalQualityValidator()
    this.cognitiveOrchestrator = new CognitiveOrchestrator()
    this.config = {
      maxCycles: 3,
      confidenceThreshold: 0.85,
      qualityThreshold: 0.8,
      ...config
    }
  }

  async processWithValidation(
    medicalCase: MedicalCase,
    onProgressUpdate?: (cycle: DiagnosticCycle) => void
  ): Promise<SOAPAnalysis | AdditionalInfoRequest> {
    this.cycles = []
    let currentCycle = 1
    let globalConfidence = 0
    let caseData = { ...medicalCase }

    console.log('üî¨ INICIANDO PROCESO ITERATIVO DE DIAGN√ìSTICO')

    while (globalConfidence < this.config.confidenceThreshold && currentCycle <= this.config.maxCycles) {
      const cycleId = `cycle_${currentCycle}_${Date.now()}`
      
      console.log(`\nüîÑ CICLO ${currentCycle}/${this.config.maxCycles}`)
      
      const cycle = await this.runDiagnosticCycle(caseData, currentCycle, cycleId)
      this.cycles.push(cycle)

      // Emit progress update
      if (onProgressUpdate) {
        onProgressUpdate(cycle)
      }

      // Verificar si necesita m√°s datos
      const needsMoreData = this.needsMoreData(cycle.analysis)
      if (needsMoreData) {
        console.log('‚ùì DATOS INSUFICIENTES - Solicitando informaci√≥n adicional')
        return this.createAdditionalInfoRequest(cycle.analysis, currentCycle)
      }

      // Calcular confianza del ciclo
      const cycleConfidence = this.calculateCycleConfidence(cycle)
      globalConfidence = this.calculateGlobalConfidence(this.cycles)
      
      console.log(`üìä Confianza del ciclo ${currentCycle}: ${Math.round(cycleConfidence * 100)}%`)
      console.log(`üìä Confianza global: ${Math.round(globalConfidence * 100)}%`)

      // Validar calidad del an√°lisis
      const qualityScore = this.evaluateAnalysisQuality(cycle.analysis)
      if (qualityScore < this.config.qualityThreshold && currentCycle < this.config.maxCycles) {
        console.log(`‚ö†Ô∏è Calidad insuficiente (${Math.round(qualityScore * 100)}%) - Refinando an√°lisis`)
        caseData = this.enhanceCaseWithInsights(caseData, cycle)
      }

      currentCycle++
    }

    console.log(`\n‚úÖ DIAGN√ìSTICO COMPLETADO despu√©s de ${this.cycles.length} ciclos`)
    console.log(`üìä Confianza final: ${Math.round(globalConfidence * 100)}%`)

    return await this.finalizeSOAPAnalysis(this.cycles)
  }

  private async runDiagnosticCycle(
    caseData: MedicalCase,
    cycleNumber: number,
    cycleId: string
  ): Promise<DiagnosticCycle> {
    const startTime = Date.now()

    // Crear prompt espec√≠fico para este ciclo
    const cyclePrompt = this.buildCyclePrompt(caseData, cycleNumber, this.cycles)

    console.log(`üìù Enviando a Claude (Ciclo ${cycleNumber})...`)

    // Hacer llamada a Claude
    const response = await this.claudeAdapter.makeRequest(
      this.buildSystemPrompt(cycleNumber),
      cyclePrompt
    )

    // Verificar si hay error de configuraci√≥n
    if (!response.success && response.error === 'API_KEY_NOT_CONFIGURED') {
      // Retornar an√°lisis especial que contenga el mensaje de configuraci√≥n
      return {
        id: cycleId,
        cycleNumber,
        timestamp: startTime,
        latency: Date.now() - startTime,
        caseData,
        analysis: {
          subjetivo: '## ‚ö†Ô∏è Configuraci√≥n Requerida',
          objetivo: response.content, // Contiene las instrucciones completas
          diagnostico_principal: 'Configuraci√≥n de API Key pendiente',
          diagnosticos_diferenciales: ['Configurar CLAUDE_API_KEY en servidor'],
          plan_tratamiento: 'Seguir las instrucciones mostradas para configurar Claude API',
          confianza_global: 0,
          datos_adicionales_necesarios: []
        },
        confidence: 0,
        qualityScore: 0,
        insights: ['Sistema requiere configuraci√≥n de API Key'],
        nextSteps: ['Configurar Claude API Key', 'Reiniciar servidor', 'Probar nuevamente']
      }
    }

    const endTime = Date.now()
    const latency = endTime - startTime

    // Parsear respuesta en estructura SOAP
    const analysis = this.parseClaudeResponse(response.content)

    return {
      id: cycleId,
      cycleNumber,
      timestamp: startTime,
      latency,
      caseData,
      analysis,
      confidence: this.calculateAnalysisConfidence(analysis),
      qualityScore: this.evaluateAnalysisQuality(analysis),
      insights: this.extractInsights(analysis),
      nextSteps: this.determineNextSteps(analysis, cycleNumber)
    }
  }

  private buildSystemPrompt(cycleNumber: number): string {
    const basePrompt = `Eres un m√©dico especialista realizando un an√°lisis cl√≠nico iterativo.
    
CICLO DE AN√ÅLISIS: ${cycleNumber}
OBJETIVO: An√°lisis m√©dico progresivo siguiendo metodolog√≠a SOAP

INSTRUCCIONES CR√çTICAS:
- Si es el primer ciclo, haz an√°lisis inicial completo
- Si es ciclo posterior, refina y mejora el an√°lisis previo
- SIEMPRE responde en formato SOAP estructurado
- Indica nivel de confianza en cada secci√≥n
- Si faltan datos cr√≠ticos, especif√≠calo claramente`

    if (cycleNumber === 1) {
      return basePrompt + `

AN√ÅLISIS INICIAL - Eval√∫a con la informaci√≥n disponible:
- Identifica patrones cl√≠nicos principales
- Lista diagn√≥sticos diferenciales por probabilidad Y gravedad
- Indica qu√© datos adicionales ser√≠an cr√≠ticos`
    }

    return basePrompt + `

AN√ÅLISIS REFINADO - Mejora el an√°lisis previo:
- Incorpora insights del ciclo anterior
- Ajusta diagn√≥sticos diferenciales
- Aumenta especificidad del plan terap√©utico`
  }

  private buildCyclePrompt(caseData: MedicalCase, cycleNumber: number, previousCycles: DiagnosticCycle[]): string {
    let prompt = `
## CASO CL√çNICO - CICLO ${cycleNumber}

**Datos del Paciente:**
${caseData.presentation}

**Historia Cl√≠nica Disponible:**
${caseData.history || 'Informaci√≥n limitada disponible'}

**Contexto:** ${caseData.context || 'Consulta m√©dica general'}
`

    // Agregar insights de ciclos previos
    if (previousCycles.length > 0) {
      prompt += `\n## AN√ÅLISIS PREVIO - CICLO ${cycleNumber - 1}\n`
      const lastCycle = previousCycles[previousCycles.length - 1]
      prompt += `**Diagn√≥stico previo:** ${lastCycle.analysis?.diagnostico_principal || 'En proceso'}\n`
      prompt += `**Confianza previa:** ${Math.round((lastCycle.confidence || 0) * 100)}%\n`
      
      if (lastCycle.insights && lastCycle.insights.length > 0) {
        prompt += `**Insights identificados:**\n${lastCycle.insights.join('\n- ')}\n`
      }
    }

    prompt += `\n## SOLICITUD DE AN√ÅLISIS SOAP

Responde EXCLUSIVAMENTE en este formato:

## S - SUBJETIVO
[S√≠ntomas reportados por el paciente]
**Confianza:** [0-100]%

## O - OBJETIVO
[Signos vitales y hallazgos f√≠sicos inferidos/disponibles]
**Confianza:** [0-100]%

## A - AN√ÅLISIS
**Diagn√≥stico Principal:** [Diagn√≥stico m√°s probable]
**Diagn√≥sticos Diferenciales:**
1. [ALTA GRAVEDAD - descartar urgente] - Probabilidad: X%
2. [ALTA PROBABILIDAD - com√∫n en contexto] - Probabilidad: X%
3. [Otras consideraciones] - Probabilidad: X%
**Confianza global:** [0-100]%

## P - PLAN
**Inmediato:** [Tratamiento ahora]
**Seguimiento:** [Cu√°ndo revisar - espec√≠fico]
**Derivaci√≥n:** [Cu√°ndo referir especialista]
**Estudios:** [Qu√© estudios solicitar - prioridad]
**Confianza:** [0-100]%

## DATOS ADICIONALES NECESARIOS
[Lista espec√≠fica de informaci√≥n que mejorar√≠a el diagn√≥stico]
`

    return prompt
  }

  private parseClaudeResponse(response: string): SOAPAnalysis {
    console.log('üîç Respuesta de Claude recibida:', response.substring(0, 500) + '...')
    
    // Parser m√°s flexible para diferentes formatos de respuesta
    const sections = {
      subjetivo: this.extractSection(response, 'S - SUBJETIVO', 'O - OBJETIVO') || 
                 this.extractSection(response, 'SUBJETIVO', 'OBJETIVO') ||
                 this.extractSection(response, '**S**', '**O**') ||
                 this.extractSectionFallback(response, 'subjetivo'),
      objetivo: this.extractSection(response, 'O - OBJETIVO', 'A - AN√ÅLISIS') ||
                this.extractSection(response, 'OBJETIVO', 'AN√ÅLISIS') ||
                this.extractSection(response, '**O**', '**A**') ||
                this.extractSectionFallback(response, 'objetivo'),
      analisis: this.extractSection(response, 'A - AN√ÅLISIS', 'P - PLAN') ||
                this.extractSection(response, 'AN√ÅLISIS', 'PLAN') ||
                this.extractSection(response, '**A**', '**P**') ||
                this.extractSectionFallback(response, 'an√°lisis'),
      plan: this.extractSection(response, 'P - PLAN', 'DATOS ADICIONALES') ||
            this.extractSection(response, 'PLAN', '') ||
            this.extractSection(response, '**P**', '') ||
            this.extractSectionFallback(response, 'plan')
    }

    console.log('üìù Secciones extra√≠das:', {
      subjetivo: sections.subjetivo?.substring(0, 100) + '...',
      objetivo: sections.objetivo?.substring(0, 100) + '...',
      analisis: sections.analisis?.substring(0, 100) + '...',
      plan: sections.plan?.substring(0, 100) + '...'
    })

    // Extraer diagn√≥stico principal
    const diagnostico_principal = this.extractDiagnosticoPrincipal(sections.analisis) ||
                                 this.extractDiagnosticoPrincipal(response)
    const diagnosticos_diferenciales = this.extractDiagnosticosDiferenciales(sections.analisis) ||
                                      this.extractDiagnosticosDiferenciales(response)

    return {
      subjetivo: sections.subjetivo || 'Informaci√≥n subjetiva del paciente disponible en caso cl√≠nico.',
      objetivo: sections.objetivo || 'Hallazgos objetivos a documentar durante exploraci√≥n f√≠sica.',
      diagnostico_principal: diagnostico_principal || 'Diagn√≥stico por determinar tras evaluaci√≥n completa',
      diagnosticos_diferenciales: diagnosticos_diferenciales?.length > 0 ? diagnosticos_diferenciales : ['Diagn√≥sticos diferenciales por evaluar'],
      plan_tratamiento: sections.plan || 'Plan de tratamiento por establecer seg√∫n diagn√≥stico definitivo.',
      confianza_global: this.extractConfianza(sections.analisis) || this.extractConfianza(response) || 0.5,
      datos_adicionales_necesarios: this.extractDatosAdicionales(response)
    }
  }

  private extractSection(text: string, startMarker: string, endMarker: string): string {
    const startIndex = text.indexOf(startMarker)
    const endIndex = endMarker ? text.indexOf(endMarker) : -1
    
    if (startIndex === -1) return ''
    
    const start = startIndex + startMarker.length
    const end = endIndex === -1 ? text.length : endIndex
    
    return text.substring(start, end).trim()
  }

  private extractSectionFallback(text: string, sectionType: string): string {
    // Fallback para extraer secciones cuando los marcadores est√°ndar fallan
    const patterns = {
      subjetivo: [
        /(?:motivo.*consulta|presenta|refiere)[\s\S]*?(?=objetivo|hallazgos|examen|$)/i,
        /(?:historia.*actual|evoluci√≥n)[\s\S]*?(?=objetivo|hallazgos|examen|$)/i
      ],
      objetivo: [
        /(?:examen.*f√≠sico|hallazgos|signos.*vitales)[\s\S]*?(?=an√°lisis|diagn√≥stico|impresi√≥n|$)/i,
        /(?:exploraci√≥n|inspecci√≥n|palpaci√≥n)[\s\S]*?(?=an√°lisis|diagn√≥stico|impresi√≥n|$)/i
      ],
      an√°lisis: [
        /(?:diagn√≥stico|impresi√≥n|an√°lisis)[\s\S]*?(?=plan|tratamiento|manejo|$)/i,
        /(?:diferencial|presuntivo)[\s\S]*?(?=plan|tratamiento|manejo|$)/i
      ],
      plan: [
        /(?:plan|tratamiento|manejo|recomendaciones)[\s\S]*$/i,
        /(?:medicamentos|terapia|seguimiento)[\s\S]*$/i
      ]
    }
    
    const sectionPatterns = patterns[sectionType as keyof typeof patterns] || []
    
    for (const pattern of sectionPatterns) {
      const match = text.match(pattern)
      if (match && match[0].length > 20) {
        return match[0].trim()
      }
    }
    
    return ''
  }

  private extractDiagnosticoPrincipal(analisisText: string): string {
    const patterns = [
      /\*\*Diagn√≥stico Principal:\*\*\s*(.+?)(?=\n|\*\*|$)/i,
      /Diagn√≥stico Principal:?\s*(.+?)(?=\n|Diagn√≥sticos|$)/i,
      /Impresi√≥n diagn√≥stica:?\s*(.+?)(?=\n|Diagn√≥sticos|$)/i,
      /Diagn√≥stico presuntivo:?\s*(.+?)(?=\n|Diagn√≥sticos|$)/i,
      /Principal:?\s*(.+?)(?=\n|Diferencial|$)/i,
      /(?:dermatitis|eczema|psoriasis|alergia)[\w\s]+/i
    ]
    
    for (const pattern of patterns) {
      const match = analisisText.match(pattern)
      if (match && match[1] && match[1].trim().length > 3) {
        return match[1].trim()
      }
    }
    
    return ''
  }

  private extractDiagnosticosDiferenciales(analisisText: string): string[] {
    const diferenciales: string[] = []
    const lines = analisisText.split('\n')
    let inDiferenciales = false
    
    for (const line of lines) {
      if (line.includes('Diagn√≥sticos Diferenciales')) {
        inDiferenciales = true
        continue
      }
      
      if (inDiferenciales && line.match(/^\d+\./)) {
        diferenciales.push(line.trim())
      } else if (inDiferenciales && line.includes('**')) {
        break
      }
    }
    
    return diferenciales
  }

  private extractConfianza(analisisText: string): number {
    const match = analisisText.match(/\*\*Confianza global:\*\*\s*(\d+)%/i)
    return match ? parseInt(match[1]) / 100 : 0.5
  }

  private extractDatosAdicionales(response: string): string[] {
    const section = this.extractSection(response, 'DATOS ADICIONALES NECESARIOS', '')
    return section.split('\n').filter(line => line.trim().length > 0)
  }

  private needsMoreData(analysis: SOAPAnalysis): boolean {
    // L√≥gica m√°s permisiva para determinar si necesita m√°s datos
    const hasVeryLowConfidence = (analysis.confianza_global || 0) < 0.4  // Reducido de 0.6 a 0.4
    const hasInsufficientSubjective = (analysis.subjetivo?.length || 0) < 30  // Reducido de 50 a 30
    const hasInsufficientObjective = (analysis.objetivo?.length || 0) < 20   // Reducido de 30 a 20
    const hasCriticalDataNeeds = (analysis.datos_adicionales_necesarios?.length || 0) > 3  // Aumentado de 2 a 3

    // Solo pedir informaci√≥n adicional si realmente es cr√≠tico
    return hasVeryLowConfidence && hasInsufficientSubjective && hasInsufficientObjective
  }

  private createAdditionalInfoRequest(analysis: SOAPAnalysis, currentCycle: number): AdditionalInfoRequest {
    // Generar preguntas espec√≠ficas basadas en lo que falta
    const specificQuestions = this.generateSpecificQuestions(analysis)
    const specificActions = this.generateSpecificActions(analysis)

    return {
      type: 'additional_info_needed',
      currentCycle,
      confidence: analysis.confianza_global || 0,
      questions: specificQuestions.length > 0 ? specificQuestions : analysis.datos_adicionales_necesarios || [],
      partialAnalysis: analysis,
      nextActions: specificActions.length > 0 ? specificActions : [
        'Proporcionar informaci√≥n adicional solicitada',
        'Confirmar datos demogr√°ficos si faltan',
        'Especificar cronolog√≠a de s√≠ntomas',
        'Incluir antecedentes m√©dicos relevantes'
      ]
    }
  }

  private generateSpecificQuestions(analysis: SOAPAnalysis): string[] {
    const questions: string[] = []
    
    // Analizar qu√© informaci√≥n espec√≠fica falta
    if (!analysis.subjetivo || analysis.subjetivo.length < 30) {
      questions.push('¬øPuede describir con m√°s detalle los s√≠ntomas que presenta el paciente?')
      questions.push('¬øCu√°ndo comenzaron exactamente los s√≠ntomas y c√≥mo han evolucionado?')
    }
    
    if (!analysis.objetivo || analysis.objetivo.length < 20) {
      questions.push('¬øQu√© hallazgos espec√≠ficos se encontraron en el examen f√≠sico?')
      questions.push('¬øCu√°les son los signos vitales del paciente?')
    }
    
    // Preguntas contextuales basadas en el contenido
    const content = `${analysis.subjetivo || ''} ${analysis.objetivo || ''}`.toLowerCase()
    
    if (content.includes('lesion') || content.includes('dermat')) {
      questions.push('¬øCu√°les son las caracter√≠sticas exactas de las lesiones (tama√±o, distribuci√≥n, textura)?')
      questions.push('¬øHay factores que mejoran o empeoran las lesiones?')
    }
    
    if (content.includes('dolor')) {
      questions.push('¬øPuede caracterizar mejor el dolor (intensidad 1-10, tipo, irradiaci√≥n)?')
    }
    
    return questions
  }

  private generateSpecificActions(analysis: SOAPAnalysis): string[] {
    const actions: string[] = []
    
    if (!analysis.subjetivo || analysis.subjetivo.length < 30) {
      actions.push('Ampliar descripci√≥n de s√≠ntomas y historia cl√≠nica')
    }
    
    if (!analysis.objetivo || analysis.objetivo.length < 20) {
      actions.push('Proporcionar hallazgos de examen f√≠sico y signos vitales')
    }
    
    if (!analysis.diagnostico_principal || analysis.diagnostico_principal === 'No especificado') {
      actions.push('Incluir cualquier impresi√≥n diagn√≥stica preliminar si existe')
    }
    
    return actions
  }

  private calculateCycleConfidence(cycle: DiagnosticCycle): number {
    return cycle.confidence || 0.5
  }

  private calculateGlobalConfidence(cycles: DiagnosticCycle[]): number {
    if (cycles.length === 0) return 0
    
    // La confianza global aumenta con cada ciclo, pero con rendimientos decrecientes
    const latestConfidence = cycles[cycles.length - 1].confidence || 0.5
    const cycleBonus = Math.min(cycles.length * 0.1, 0.3) // Max 30% bonus
    
    return Math.min(latestConfidence + cycleBonus, 1.0)
  }

  private evaluateAnalysisQuality(analysis: SOAPAnalysis): number {
    let score = 0.5 // Base score
    
    // Evaluar completitud de secciones
    if (analysis.subjetivo && analysis.subjetivo.length > 30) score += 0.1
    if (analysis.objetivo && analysis.objetivo.length > 30) score += 0.1
    if (analysis.diagnostico_principal && analysis.diagnostico_principal !== 'No especificado') score += 0.2
    if (analysis.diagnosticos_diferenciales && analysis.diagnosticos_diferenciales.length >= 2) score += 0.15
    if (analysis.plan_tratamiento && analysis.plan_tratamiento.length > 50) score += 0.15
    
    return Math.min(score, 1.0)
  }

  private calculateAnalysisConfidence(analysis: SOAPAnalysis): number {
    return analysis.confianza_global || 0.5
  }

  private extractInsights(analysis: SOAPAnalysis): string[] {
    const insights: string[] = []
    
    // Extraer insights basados en el contenido del an√°lisis
    if (analysis.diagnosticos_diferenciales && analysis.diagnosticos_diferenciales.length > 0) {
      insights.push(`Identificados ${analysis.diagnosticos_diferenciales.length} diagn√≥sticos diferenciales`)
    }
    
    if (analysis.confianza_global && analysis.confianza_global > 0.8) {
      insights.push('Alta confianza en el an√°lisis diagn√≥stico')
    }
    
    if (analysis.datos_adicionales_necesarios && analysis.datos_adicionales_necesarios.length > 0) {
      insights.push(`Necesarios ${analysis.datos_adicionales_necesarios.length} datos adicionales para completar diagn√≥stico`)
    }
    
    return insights
  }

  private determineNextSteps(analysis: SOAPAnalysis, cycleNumber: number): string[] {
    const steps: string[] = []
    
    if (analysis.confianza_global && analysis.confianza_global < 0.7) {
      steps.push('Refinar an√°lisis diagn√≥stico')
    }
    
    if (analysis.datos_adicionales_necesarios && analysis.datos_adicionales_necesarios.length > 0) {
      steps.push('Solicitar informaci√≥n adicional al m√©dico')
    }
    
    if (cycleNumber >= this.config.maxCycles) {
      steps.push('Finalizar an√°lisis con recomendaciones actuales')
    } else {
      steps.push('Continuar al siguiente ciclo de an√°lisis')
    }
    
    return steps
  }

  private enhanceCaseWithInsights(caseData: MedicalCase, cycle: DiagnosticCycle): MedicalCase {
    // Agregar insights del ciclo al contexto del caso
    const enhancedContext = `${caseData.context || ''}\n\nInsights del an√°lisis previo:\n${cycle.insights?.join('\n- ') || ''}`
    
    return {
      ...caseData,
      context: enhancedContext.trim()
    }
  }

  private async finalizeSOAPAnalysis(cycles: DiagnosticCycle[]): Promise<SOAPAnalysis> {
    const lastCycle = cycles[cycles.length - 1]
    const finalAnalysis = lastCycle.analysis
    const globalConfidence = this.calculateGlobalConfidence(cycles)

    console.log('üß† ACTIVANDO ORQUESTADOR COGNITIVO PARA AN√ÅLISIS FINAL')
    
    // Si tenemos alta confianza, usar el orquestador cognitivo para refinar el an√°lisis
    if (globalConfidence >= 0.8) {
      try {
        // Crear input estructurado para el orquestador
        const structuredInput = this.buildStructuredInputForOrchestrator(cycles, finalAnalysis)
        
        // Procesar con orquestador cognitivo (agentes especializados)
        const cognitiveResult = await this.cognitiveOrchestrator.processWithCognition(structuredInput)
        
        console.log(`üéØ Orquestador activ√≥ ${cognitiveResult.decisions.length} agentes especializados`)
        console.log(`üìä Consenso alcanzado: ${cognitiveResult.consensus ? 'S√ç' : 'NO'}`)
        
        // Mejorar an√°lisis SOAP con insights cognitivos
        const enhancedAnalysis = this.enhanceSOAPWithCognitiveInsights(
          finalAnalysis, 
          cognitiveResult, 
          cycles
        )
        
        return enhancedAnalysis
        
      } catch (error) {
        console.warn('‚ö†Ô∏è Error en orquestador cognitivo, usando an√°lisis b√°sico:', error)
        // Fallback al an√°lisis b√°sico si falla el orquestador
      }
    }

    // An√°lisis b√°sico sin orquestador cognitivo
    return {
      ...finalAnalysis,
      confianza_global: globalConfidence,
      ciclos_diagnosticos: cycles.length,
      tiempo_total_analisis: cycles.reduce((sum, cycle) => sum + (cycle.latency || 0), 0),
      evolucion_diagnostica: cycles.map((cycle, index) => ({
        ciclo: index + 1,
        diagnostico: cycle.analysis?.diagnostico_principal || 'En proceso',
        confianza: cycle.confidence || 0
      }))
    }
  }

  /**
   * Construye input estructurado para el orquestador basado en los ciclos diagn√≥sticos
   */
  private buildStructuredInputForOrchestrator(cycles: DiagnosticCycle[], analysis: SOAPAnalysis): string {
    const lastCycle = cycles[cycles.length - 1]
    
    return `CASO CL√çNICO PARA AN√ÅLISIS MULTI-AGENTE:

INFORMACI√ìN CL√çNICA BASE:
${lastCycle.caseData.presentation}

AN√ÅLISIS ITERATIVO PREVIO:
- Ciclos completados: ${cycles.length}
- Confianza alcanzada: ${Math.round(this.calculateGlobalConfidence(cycles) * 100)}%

SOAP PRELIMINAR:
S: ${analysis.subjetivo}
O: ${analysis.objetivo}  
A: ${analysis.diagnostico_principal}
P: ${analysis.plan_tratamiento}

DIAGN√ìSTICOS DIFERENCIALES:
${analysis.diagnosticos_diferenciales?.map((dx: string, i: number) => `${i + 1}. ${dx}`).join('\n') || 'No especificados'}

SOLICITUD: Coordinar agentes especializados seg√∫n contexto cl√≠nico para validaci√≥n final y refinamiento diagn√≥stico.`
  }

  /**
   * Mejora el an√°lisis SOAP con insights del orquestador cognitivo
   */
  private enhanceSOAPWithCognitiveInsights(
    baseAnalysis: SOAPAnalysis,
    cognitiveResult: any,
    cycles: DiagnosticCycle[]
  ): SOAPAnalysis {
    
    // Extraer insights de las decisiones de agentes especializados
    const specialistInsights = cognitiveResult.decisions
      .filter((decision: any) => decision.confidence > 0.7)
      .map((decision: any) => decision.content)
      .join('\n\n')

    // Mejorar cada secci√≥n con insights cognitivos
    const enhancedSubjetivo = baseAnalysis.subjetivo + 
      (specialistInsights ? `\n\n**Insights de Especialistas:**\n${specialistInsights}` : '')

    const enhancedAnalysis = {
      ...baseAnalysis,
      subjetivo: enhancedSubjetivo,
      confianza_global: Math.min(this.calculateGlobalConfidence(cycles) + 0.1, 1.0), // Bonus por orquestador
      ciclos_diagnosticos: cycles.length,
      tiempo_total_analisis: cycles.reduce((sum, cycle) => sum + (cycle.latency || 0), 0),
      evolucion_diagnostica: cycles.map((cycle, index) => ({
        ciclo: index + 1,
        diagnostico: cycle.analysis?.diagnostico_principal || 'En proceso',
        confianza: cycle.confidence || 0
      })),
      // Agregar metadata del orquestrador
      analisis_cognitivo: {
        agentes_consultados: cognitiveResult.decisions.length,
        consenso_alcanzado: Boolean(cognitiveResult.consensus),
        insights_memoria: cognitiveResult.memory?.shortTermMemory?.relevantContext || 'No disponible',
        validacion_especializada: true
      }
    }

    console.log('‚úÖ An√°lisis SOAP mejorado con orquestador cognitivo')
    return enhancedAnalysis
  }

  // M√©todos p√∫blicos para acceso a datos
  public getCycles(): DiagnosticCycle[] {
    return [...this.cycles]
  }

  public getLastCycle(): DiagnosticCycle | null {
    return this.cycles.length > 0 ? this.cycles[this.cycles.length - 1] : null
  }

  public getCurrentConfidence(): number {
    return this.calculateGlobalConfidence(this.cycles)
  }
}